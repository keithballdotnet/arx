// Code generated by protoc-gen-go.
// source: src/github.com/keithballdotnet/arx/proto/arx.proto
// DO NOT EDIT!

/*
Package arx is a generated protocol buffer package.

It is generated from these files:
	src/github.com/keithballdotnet/arx/proto/arx.proto

It has these top-level messages:
	KeyMetadata
	Key
	KeyVersion
	CreateKeyRequest
	ListKeysRequest
	RotateKeyRequest
	RotateKeyResponse
	EnableKeyRequest
	DisableKeyRequest
	GenerateDataKeyRequest
	GenerateDataKeyResponse
	EncryptRequest
	EncryptResponse
	DecryptRequest
	DecryptResponse
	ReEncryptRequest
	ReEncryptResponse
*/
package arx

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// KeyMetadata is a representation of an Encryption Key
type KeyMetadata struct {
	KeyID                   string `protobuf:"bytes,1,opt,name=KeyID,json=keyID" json:"KeyID,omitempty"`
	CreationDateRFC3339Nano string `protobuf:"bytes,2,opt,name=CreationDateRFC3339Nano,json=creationDateRFC3339Nano" json:"CreationDateRFC3339Nano,omitempty"`
	Description             string `protobuf:"bytes,3,opt,name=Description,json=description" json:"Description,omitempty"`
	Enabled                 bool   `protobuf:"varint,4,opt,name=Enabled,json=enabled" json:"Enabled,omitempty"`
}

func (m *KeyMetadata) Reset()                    { *m = KeyMetadata{} }
func (m *KeyMetadata) String() string            { return proto.CompactTextString(m) }
func (*KeyMetadata) ProtoMessage()               {}
func (*KeyMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Key is a represention of a key
type Key struct {
	Metadata *KeyMetadata  `protobuf:"bytes,1,opt,name=Metadata,json=metadata" json:"Metadata,omitempty"`
	Versions []*KeyVersion `protobuf:"bytes,2,rep,name=Versions,json=versions" json:"Versions,omitempty"`
}

func (m *Key) Reset()                    { *m = Key{} }
func (m *Key) String() string            { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()               {}
func (*Key) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Key) GetMetadata() *KeyMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Key) GetVersions() []*KeyVersion {
	if m != nil {
		return m.Versions
	}
	return nil
}

// KeyVersion is a version of a key
type KeyVersion struct {
	Version int64  `protobuf:"varint,1,opt,name=Version,json=version" json:"Version,omitempty"`
	Key     []byte `protobuf:"bytes,2,opt,name=Key,json=key,proto3" json:"Key,omitempty"`
}

func (m *KeyVersion) Reset()                    { *m = KeyVersion{} }
func (m *KeyVersion) String() string            { return proto.CompactTextString(m) }
func (*KeyVersion) ProtoMessage()               {}
func (*KeyVersion) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// CreateKeyRequest will create a key
type CreateKeyRequest struct {
	Description string `protobuf:"bytes,1,opt,name=Description,json=description" json:"Description,omitempty"`
}

func (m *CreateKeyRequest) Reset()                    { *m = CreateKeyRequest{} }
func (m *CreateKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateKeyRequest) ProtoMessage()               {}
func (*CreateKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// ListKeysRequest will stream a list of available keys back to the user
type ListKeysRequest struct {
}

func (m *ListKeysRequest) Reset()                    { *m = ListKeysRequest{} }
func (m *ListKeysRequest) String() string            { return proto.CompactTextString(m) }
func (*ListKeysRequest) ProtoMessage()               {}
func (*ListKeysRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// RotateKeyRequest will rotate a key
type RotateKeyRequest struct {
	KeyID string `protobuf:"bytes,1,opt,name=KeyID,json=keyID" json:"KeyID,omitempty"`
}

func (m *RotateKeyRequest) Reset()                    { *m = RotateKeyRequest{} }
func (m *RotateKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*RotateKeyRequest) ProtoMessage()               {}
func (*RotateKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// RotateKeyResponse will rotate a key
type RotateKeyResponse struct {
	Success bool `protobuf:"varint,1,opt,name=Success,json=success" json:"Success,omitempty"`
}

func (m *RotateKeyResponse) Reset()                    { *m = RotateKeyResponse{} }
func (m *RotateKeyResponse) String() string            { return proto.CompactTextString(m) }
func (*RotateKeyResponse) ProtoMessage()               {}
func (*RotateKeyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

// EnableKeyRequest will enable a key
type EnableKeyRequest struct {
	KeyID string `protobuf:"bytes,1,opt,name=KeyID,json=keyID" json:"KeyID,omitempty"`
}

func (m *EnableKeyRequest) Reset()                    { *m = EnableKeyRequest{} }
func (m *EnableKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*EnableKeyRequest) ProtoMessage()               {}
func (*EnableKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

// DisableKeyRequest will disable a key
type DisableKeyRequest struct {
	KeyID string `protobuf:"bytes,1,opt,name=KeyID,json=keyID" json:"KeyID,omitempty"`
}

func (m *DisableKeyRequest) Reset()                    { *m = DisableKeyRequest{} }
func (m *DisableKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*DisableKeyRequest) ProtoMessage()               {}
func (*DisableKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

// GenerateDataKeyRequest will request a new data key
type GenerateDataKeyRequest struct {
	KeyID string `protobuf:"bytes,1,opt,name=KeyID,json=keyID" json:"KeyID,omitempty"`
}

func (m *GenerateDataKeyRequest) Reset()                    { *m = GenerateDataKeyRequest{} }
func (m *GenerateDataKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*GenerateDataKeyRequest) ProtoMessage()               {}
func (*GenerateDataKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

// GenerateDataKeyResponse ...
type GenerateDataKeyResponse struct {
	Plaintext      []byte `protobuf:"bytes,1,opt,name=Plaintext,json=plaintext,proto3" json:"Plaintext,omitempty"`
	CiphertextBlob []byte `protobuf:"bytes,2,opt,name=CiphertextBlob,json=ciphertextBlob,proto3" json:"CiphertextBlob,omitempty"`
}

func (m *GenerateDataKeyResponse) Reset()                    { *m = GenerateDataKeyResponse{} }
func (m *GenerateDataKeyResponse) String() string            { return proto.CompactTextString(m) }
func (*GenerateDataKeyResponse) ProtoMessage()               {}
func (*GenerateDataKeyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

// EncryptRequest ...
type EncryptRequest struct {
	KeyID     string `protobuf:"bytes,1,opt,name=KeyID,json=keyID" json:"KeyID,omitempty"`
	Plaintext []byte `protobuf:"bytes,2,opt,name=Plaintext,json=plaintext,proto3" json:"Plaintext,omitempty"`
}

func (m *EncryptRequest) Reset()                    { *m = EncryptRequest{} }
func (m *EncryptRequest) String() string            { return proto.CompactTextString(m) }
func (*EncryptRequest) ProtoMessage()               {}
func (*EncryptRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

// EncryptResponse ...
type EncryptResponse struct {
	CiphertextBlob []byte `protobuf:"bytes,1,opt,name=CiphertextBlob,json=ciphertextBlob,proto3" json:"CiphertextBlob,omitempty"`
}

func (m *EncryptResponse) Reset()                    { *m = EncryptResponse{} }
func (m *EncryptResponse) String() string            { return proto.CompactTextString(m) }
func (*EncryptResponse) ProtoMessage()               {}
func (*EncryptResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

// DecryptRequest ...
type DecryptRequest struct {
	CiphertextBlob []byte `protobuf:"bytes,1,opt,name=CiphertextBlob,json=ciphertextBlob,proto3" json:"CiphertextBlob,omitempty"`
}

func (m *DecryptRequest) Reset()                    { *m = DecryptRequest{} }
func (m *DecryptRequest) String() string            { return proto.CompactTextString(m) }
func (*DecryptRequest) ProtoMessage()               {}
func (*DecryptRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

// DecryptResponse ...
type DecryptResponse struct {
	Plaintext []byte `protobuf:"bytes,1,opt,name=Plaintext,json=plaintext,proto3" json:"Plaintext,omitempty"`
}

func (m *DecryptResponse) Reset()                    { *m = DecryptResponse{} }
func (m *DecryptResponse) String() string            { return proto.CompactTextString(m) }
func (*DecryptResponse) ProtoMessage()               {}
func (*DecryptResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

// ReEncryptRequest ...
type ReEncryptRequest struct {
	CiphertextBlob   []byte `protobuf:"bytes,1,opt,name=CiphertextBlob,json=ciphertextBlob,proto3" json:"CiphertextBlob,omitempty"`
	DestinationKeyID string `protobuf:"bytes,2,opt,name=DestinationKeyID,json=destinationKeyID" json:"DestinationKeyID,omitempty"`
}

func (m *ReEncryptRequest) Reset()                    { *m = ReEncryptRequest{} }
func (m *ReEncryptRequest) String() string            { return proto.CompactTextString(m) }
func (*ReEncryptRequest) ProtoMessage()               {}
func (*ReEncryptRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

// ReEncryptResponse ...
type ReEncryptResponse struct {
	CiphertextBlob []byte `protobuf:"bytes,1,opt,name=CiphertextBlob,json=ciphertextBlob,proto3" json:"CiphertextBlob,omitempty"`
	KeyID          string `protobuf:"bytes,2,opt,name=KeyID,json=keyID" json:"KeyID,omitempty"`
	SourceKeyID    string `protobuf:"bytes,3,opt,name=SourceKeyID,json=sourceKeyID" json:"SourceKeyID,omitempty"`
}

func (m *ReEncryptResponse) Reset()                    { *m = ReEncryptResponse{} }
func (m *ReEncryptResponse) String() string            { return proto.CompactTextString(m) }
func (*ReEncryptResponse) ProtoMessage()               {}
func (*ReEncryptResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func init() {
	proto.RegisterType((*KeyMetadata)(nil), "arx.KeyMetadata")
	proto.RegisterType((*Key)(nil), "arx.Key")
	proto.RegisterType((*KeyVersion)(nil), "arx.KeyVersion")
	proto.RegisterType((*CreateKeyRequest)(nil), "arx.CreateKeyRequest")
	proto.RegisterType((*ListKeysRequest)(nil), "arx.ListKeysRequest")
	proto.RegisterType((*RotateKeyRequest)(nil), "arx.RotateKeyRequest")
	proto.RegisterType((*RotateKeyResponse)(nil), "arx.RotateKeyResponse")
	proto.RegisterType((*EnableKeyRequest)(nil), "arx.EnableKeyRequest")
	proto.RegisterType((*DisableKeyRequest)(nil), "arx.DisableKeyRequest")
	proto.RegisterType((*GenerateDataKeyRequest)(nil), "arx.GenerateDataKeyRequest")
	proto.RegisterType((*GenerateDataKeyResponse)(nil), "arx.GenerateDataKeyResponse")
	proto.RegisterType((*EncryptRequest)(nil), "arx.EncryptRequest")
	proto.RegisterType((*EncryptResponse)(nil), "arx.EncryptResponse")
	proto.RegisterType((*DecryptRequest)(nil), "arx.DecryptRequest")
	proto.RegisterType((*DecryptResponse)(nil), "arx.DecryptResponse")
	proto.RegisterType((*ReEncryptRequest)(nil), "arx.ReEncryptRequest")
	proto.RegisterType((*ReEncryptResponse)(nil), "arx.ReEncryptResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion1

// Client API for Arx service

type ArxClient interface {
	//
	// Creates a new key
	//
	CreateKey(ctx context.Context, in *CreateKeyRequest, opts ...grpc.CallOption) (*KeyMetadata, error)
	//
	// Stream a list of keys back to the client
	//
	ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (Arx_ListKeysClient, error)
	//
	// Rotate a key
	//
	RotateKey(ctx context.Context, in *RotateKeyRequest, opts ...grpc.CallOption) (*RotateKeyResponse, error)
	//
	// Enable a key
	//
	EnableKey(ctx context.Context, in *EnableKeyRequest, opts ...grpc.CallOption) (*KeyMetadata, error)
	//
	// Disable a key
	//
	DisableKey(ctx context.Context, in *DisableKeyRequest, opts ...grpc.CallOption) (*KeyMetadata, error)
	//
	// Generate a data key
	//
	GenerateDataKey(ctx context.Context, in *GenerateDataKeyRequest, opts ...grpc.CallOption) (*GenerateDataKeyResponse, error)
	//
	// Encrypt data
	//
	Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error)
	//
	// Decrypt data
	//
	Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error)
	//
	// ReEncrypt data
	//
	ReEncrypt(ctx context.Context, in *ReEncryptRequest, opts ...grpc.CallOption) (*ReEncryptResponse, error)
}

type arxClient struct {
	cc *grpc.ClientConn
}

func NewArxClient(cc *grpc.ClientConn) ArxClient {
	return &arxClient{cc}
}

func (c *arxClient) CreateKey(ctx context.Context, in *CreateKeyRequest, opts ...grpc.CallOption) (*KeyMetadata, error) {
	out := new(KeyMetadata)
	err := grpc.Invoke(ctx, "/arx.arx/CreateKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arxClient) ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (Arx_ListKeysClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Arx_serviceDesc.Streams[0], c.cc, "/arx.arx/ListKeys", opts...)
	if err != nil {
		return nil, err
	}
	x := &arxListKeysClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Arx_ListKeysClient interface {
	Recv() (*KeyMetadata, error)
	grpc.ClientStream
}

type arxListKeysClient struct {
	grpc.ClientStream
}

func (x *arxListKeysClient) Recv() (*KeyMetadata, error) {
	m := new(KeyMetadata)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *arxClient) RotateKey(ctx context.Context, in *RotateKeyRequest, opts ...grpc.CallOption) (*RotateKeyResponse, error) {
	out := new(RotateKeyResponse)
	err := grpc.Invoke(ctx, "/arx.arx/RotateKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arxClient) EnableKey(ctx context.Context, in *EnableKeyRequest, opts ...grpc.CallOption) (*KeyMetadata, error) {
	out := new(KeyMetadata)
	err := grpc.Invoke(ctx, "/arx.arx/EnableKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arxClient) DisableKey(ctx context.Context, in *DisableKeyRequest, opts ...grpc.CallOption) (*KeyMetadata, error) {
	out := new(KeyMetadata)
	err := grpc.Invoke(ctx, "/arx.arx/DisableKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arxClient) GenerateDataKey(ctx context.Context, in *GenerateDataKeyRequest, opts ...grpc.CallOption) (*GenerateDataKeyResponse, error) {
	out := new(GenerateDataKeyResponse)
	err := grpc.Invoke(ctx, "/arx.arx/GenerateDataKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arxClient) Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error) {
	out := new(EncryptResponse)
	err := grpc.Invoke(ctx, "/arx.arx/Encrypt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arxClient) Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error) {
	out := new(DecryptResponse)
	err := grpc.Invoke(ctx, "/arx.arx/Decrypt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *arxClient) ReEncrypt(ctx context.Context, in *ReEncryptRequest, opts ...grpc.CallOption) (*ReEncryptResponse, error) {
	out := new(ReEncryptResponse)
	err := grpc.Invoke(ctx, "/arx.arx/ReEncrypt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Arx service

type ArxServer interface {
	//
	// Creates a new key
	//
	CreateKey(context.Context, *CreateKeyRequest) (*KeyMetadata, error)
	//
	// Stream a list of keys back to the client
	//
	ListKeys(*ListKeysRequest, Arx_ListKeysServer) error
	//
	// Rotate a key
	//
	RotateKey(context.Context, *RotateKeyRequest) (*RotateKeyResponse, error)
	//
	// Enable a key
	//
	EnableKey(context.Context, *EnableKeyRequest) (*KeyMetadata, error)
	//
	// Disable a key
	//
	DisableKey(context.Context, *DisableKeyRequest) (*KeyMetadata, error)
	//
	// Generate a data key
	//
	GenerateDataKey(context.Context, *GenerateDataKeyRequest) (*GenerateDataKeyResponse, error)
	//
	// Encrypt data
	//
	Encrypt(context.Context, *EncryptRequest) (*EncryptResponse, error)
	//
	// Decrypt data
	//
	Decrypt(context.Context, *DecryptRequest) (*DecryptResponse, error)
	//
	// ReEncrypt data
	//
	ReEncrypt(context.Context, *ReEncryptRequest) (*ReEncryptResponse, error)
}

func RegisterArxServer(s *grpc.Server, srv ArxServer) {
	s.RegisterService(&_Arx_serviceDesc, srv)
}

func _Arx_CreateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(CreateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ArxServer).CreateKey(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Arx_ListKeys_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListKeysRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ArxServer).ListKeys(m, &arxListKeysServer{stream})
}

type Arx_ListKeysServer interface {
	Send(*KeyMetadata) error
	grpc.ServerStream
}

type arxListKeysServer struct {
	grpc.ServerStream
}

func (x *arxListKeysServer) Send(m *KeyMetadata) error {
	return x.ServerStream.SendMsg(m)
}

func _Arx_RotateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RotateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ArxServer).RotateKey(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Arx_EnableKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(EnableKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ArxServer).EnableKey(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Arx_DisableKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DisableKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ArxServer).DisableKey(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Arx_GenerateDataKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GenerateDataKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ArxServer).GenerateDataKey(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Arx_Encrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(EncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ArxServer).Encrypt(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Arx_Decrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ArxServer).Decrypt(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Arx_ReEncrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReEncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ArxServer).ReEncrypt(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Arx_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arx.arx",
	HandlerType: (*ArxServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateKey",
			Handler:    _Arx_CreateKey_Handler,
		},
		{
			MethodName: "RotateKey",
			Handler:    _Arx_RotateKey_Handler,
		},
		{
			MethodName: "EnableKey",
			Handler:    _Arx_EnableKey_Handler,
		},
		{
			MethodName: "DisableKey",
			Handler:    _Arx_DisableKey_Handler,
		},
		{
			MethodName: "GenerateDataKey",
			Handler:    _Arx_GenerateDataKey_Handler,
		},
		{
			MethodName: "Encrypt",
			Handler:    _Arx_Encrypt_Handler,
		},
		{
			MethodName: "Decrypt",
			Handler:    _Arx_Decrypt_Handler,
		},
		{
			MethodName: "ReEncrypt",
			Handler:    _Arx_ReEncrypt_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListKeys",
			Handler:       _Arx_ListKeys_Handler,
			ServerStreams: true,
		},
	},
}

var fileDescriptor0 = []byte{
	// 637 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x55, 0x5f, 0x6f, 0xd3, 0x3e,
	0x14, 0xfd, 0x65, 0xd9, 0x7e, 0x4d, 0x6e, 0xa7, 0x36, 0x33, 0x63, 0xab, 0xca, 0x1e, 0x26, 0x3f,
	0xa0, 0xf1, 0xaf, 0x45, 0x2d, 0x42, 0x9d, 0xc4, 0x13, 0xcd, 0x40, 0x08, 0x98, 0x50, 0x26, 0xf1,
	0x0a, 0x69, 0x7a, 0x61, 0xd1, 0xba, 0x24, 0xc4, 0x2e, 0xda, 0x3e, 0x0a, 0xcf, 0x7c, 0x51, 0x1c,
	0xc7, 0x69, 0x13, 0x27, 0x62, 0x15, 0x6f, 0xf6, 0xf5, 0x3d, 0xbe, 0xe7, 0x9e, 0xdc, 0xe3, 0xc0,
	0x88, 0xa5, 0xc1, 0xf0, 0x7b, 0xc8, 0x2f, 0x97, 0xb3, 0x41, 0x10, 0x5f, 0x0f, 0xaf, 0x50, 0xac,
	0x67, 0xfe, 0x62, 0x31, 0x8f, 0x79, 0x84, 0x7c, 0xe8, 0xa7, 0x37, 0xc3, 0x24, 0x8d, 0x79, 0x9c,
	0xad, 0x06, 0x72, 0x45, 0x4c, 0xb1, 0xa4, 0xbf, 0x0c, 0x68, 0xbf, 0xc7, 0xdb, 0x8f, 0xc8, 0xfd,
	0xb9, 0xcf, 0x7d, 0xb2, 0x0f, 0x3b, 0x62, 0xfb, 0xce, 0xed, 0x19, 0xc7, 0xc6, 0x89, 0xed, 0xed,
	0x5c, 0x65, 0x1b, 0x32, 0x81, 0xc3, 0x69, 0x8a, 0x3e, 0x0f, 0xe3, 0xc8, 0xf5, 0x39, 0x7a, 0x6f,
	0xa6, 0xe3, 0xf1, 0xf8, 0xf4, 0xdc, 0x8f, 0xe2, 0xde, 0x96, 0xcc, 0x3b, 0x0c, 0x9a, 0x8f, 0xc9,
	0x31, 0xb4, 0x5d, 0x64, 0x41, 0x1a, 0x26, 0xd9, 0x69, 0xcf, 0x94, 0xd9, 0xed, 0xf9, 0x3a, 0x44,
	0x7a, 0xd0, 0x3a, 0x8b, 0xfc, 0xd9, 0x02, 0xe7, 0xbd, 0x6d, 0x71, 0x6a, 0x79, 0x2d, 0xcc, 0xb7,
	0xf4, 0x2b, 0x98, 0x82, 0x0b, 0x79, 0x0a, 0x56, 0x41, 0x4f, 0xb2, 0x6a, 0x8f, 0x9c, 0x41, 0xd6,
	0x45, 0x89, 0xb6, 0x67, 0x5d, 0x17, 0x0d, 0x3c, 0x01, 0xeb, 0x33, 0xa6, 0x4c, 0xdc, 0xcc, 0x04,
	0x37, 0x53, 0x64, 0x77, 0x8b, 0x6c, 0x15, 0xf7, 0xac, 0x9f, 0x2a, 0x81, 0x4e, 0x00, 0xd6, 0xf1,
	0x8c, 0x89, 0x5a, 0xca, 0x3a, 0xa6, 0xd7, 0x52, 0x89, 0xc4, 0x91, 0x4c, 0x64, 0xaf, 0xbb, 0x9e,
	0x29, 0x34, 0xa1, 0x2f, 0xc0, 0x91, 0x8a, 0xa0, 0x88, 0x7b, 0xf8, 0x63, 0x89, 0x8c, 0xeb, 0xbd,
	0x1a, 0xb5, 0x5e, 0xe9, 0x1e, 0x74, 0x3f, 0x84, 0x8c, 0x0b, 0x0c, 0x53, 0x20, 0x7a, 0x02, 0x8e,
	0x17, 0xf3, 0xea, 0x45, 0x8d, 0x1f, 0x81, 0x3e, 0x83, 0xbd, 0x52, 0x26, 0x4b, 0x44, 0x03, 0x98,
	0x71, 0xbe, 0x58, 0x06, 0x01, 0x32, 0x26, 0x93, 0x85, 0x7a, 0x2c, 0xdf, 0x66, 0x17, 0xe7, 0xba,
	0xde, 0x79, 0xf1, 0x23, 0xd8, 0x73, 0x43, 0xb6, 0x51, 0xea, 0x00, 0x0e, 0xde, 0x62, 0x84, 0xa9,
	0x60, 0x21, 0xbe, 0xb4, 0x7f, 0x67, 0xfe, 0x17, 0x38, 0xac, 0xe5, 0x2b, 0xe6, 0x47, 0x60, 0x7f,
	0x5a, 0xf8, 0x61, 0xc4, 0xf1, 0x86, 0x4b, 0xd0, 0xae, 0x67, 0x27, 0x45, 0x80, 0x3c, 0x84, 0xce,
	0x34, 0x4c, 0x2e, 0x31, 0xcd, 0x76, 0xaf, 0x17, 0xf1, 0x4c, 0x89, 0xdf, 0x09, 0x2a, 0x51, 0xea,
	0x42, 0xe7, 0x2c, 0x0a, 0xd2, 0xdb, 0x84, 0xff, 0x95, 0x48, 0xb5, 0xda, 0x96, 0x56, 0x8d, 0x9e,
	0x42, 0x77, 0x75, 0x8b, 0xa2, 0x57, 0x27, 0x60, 0x34, 0x12, 0x98, 0x40, 0xc7, 0xc5, 0x0a, 0x81,
	0x4d, 0x91, 0x43, 0xe8, 0xae, 0x90, 0x9b, 0x68, 0x42, 0xbf, 0x89, 0x51, 0x41, 0xad, 0xdb, 0x0d,
	0x8b, 0x91, 0xc7, 0xe0, 0x88, 0xd9, 0xe4, 0x61, 0x24, 0x5d, 0x9a, 0x0b, 0x94, 0x5b, 0xd7, 0x99,
	0x6b, 0x71, 0xca, 0xc4, 0xa0, 0xe1, 0x3f, 0xea, 0xb1, 0x96, 0x7f, 0xab, 0x2c, 0xbf, 0xb0, 0xc6,
	0x45, 0xbc, 0x4c, 0x03, 0xcc, 0xcf, 0xd4, 0x33, 0xc0, 0xd6, 0xa1, 0xd1, 0xef, 0x6d, 0xc8, 0x1e,
	0x24, 0xf2, 0x12, 0xec, 0x95, 0xb1, 0xc8, 0x7d, 0x69, 0x5d, 0xdd, 0x68, 0xfd, 0x9a, 0xff, 0xe9,
	0x7f, 0x02, 0x67, 0x15, 0xd6, 0x22, 0xfb, 0xf2, 0x5c, 0x73, 0x5a, 0x13, 0xea, 0xb9, 0x41, 0x5e,
	0x81, 0xbd, 0x72, 0x95, 0xaa, 0xa7, 0xfb, 0xb1, 0x7f, 0xa0, 0x87, 0x73, 0x4d, 0x64, 0x55, 0x7b,
	0x65, 0x32, 0x85, 0xd6, 0x4d, 0xd7, 0xc8, 0x56, 0x3c, 0x3c, 0x6b, 0xcb, 0x91, 0xfc, 0xfe, 0x9a,
	0x07, 0x1b, 0x91, 0xe7, 0xd0, 0xd5, 0x1c, 0x45, 0x1e, 0xc8, 0xb4, 0x66, 0x5f, 0xf6, 0x8f, 0x9a,
	0x0f, 0x4b, 0x1d, 0xb4, 0xd4, 0xa7, 0x26, 0xf7, 0x14, 0xff, 0xf2, 0x80, 0xf5, 0xf7, 0xab, 0xc1,
	0x32, 0x4e, 0x4d, 0xaf, 0xc2, 0x55, 0x5d, 0xa0, 0x70, 0xda, 0x80, 0x0b, 0x5c, 0xa6, 0x77, 0x31,
	0x5c, 0x85, 0xde, 0xda, 0x50, 0x17, 0x7a, 0x63, 0xad, 0xea, 0xec, 0x7f, 0xf9, 0xeb, 0x1a, 0xff,
	0x09, 0x00, 0x00, 0xff, 0xff, 0xb9, 0x65, 0xae, 0xea, 0xf0, 0x06, 0x00, 0x00,
}
